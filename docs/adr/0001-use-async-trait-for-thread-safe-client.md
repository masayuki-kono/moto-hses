# ADR-0001: Use async_trait for Thread-Safe Client Trait

## Status

Accepted

## Context

Rust 1.75 (December 2023) stabilized `async fn` directly in traits (AFIT: Async Functions In Traits). This raised the question of whether to use native AFIT or continue with the `async_trait` crate for the `HsesClientOps` trait in moto-hses.

### Background

#### What is the async_trait crate?

Before Rust 1.75, `async fn` could not be defined directly in traits. The `async_trait` crate works around this limitation using macros.

```rust
// Using async_trait
#[async_trait::async_trait]
pub trait HsesClientOps: Send + Sync {
    async fn read_status(&self) -> Result<Status, ClientError>;
}
```

This macro internally transforms the code to:

```rust
// Code generated by async_trait (simplified)
pub trait HsesClientOps: Send + Sync {
    fn read_status(&self) -> Pin<Box<dyn Future<Output = Result<Status, ClientError>> + Send + '_>>;
}
```

> Note: The actual expansion includes additional lifetime parameters and bounds (`'async_trait`). The `Send` bound can be omitted via `#[async_trait(?Send)]`.

#### What is Native AFIT?

Since Rust 1.75, `async fn` can be used directly in traits:

```rust
// Native AFIT
pub trait HsesClientOps: Send + Sync {
    async fn read_status(&self) -> Result<Status, ClientError>;
}
```

### Comparison

| Feature | async_trait | Native AFIT |
|---------|-------------|-------------|
| **Heap allocation** | `Box<dyn Future>` on every call | None (monomorphized future) |
| **Send bound specification** | Automatically adds `+ Send` | No stable syntax to express `Send` bounds on returned futures |
| **dyn Trait support** | Supported | Not supported (not object-safe) |
| **Compile time** | Macro expansion overhead | None |
| **MSRV** | Rust 1.39+ | Rust 1.75+ |
| **Dependencies** | Requires async_trait crate | Standard library only |

### Limitations of Native AFIT

#### 1. The Send Bound Problem

**Problem**: In multi-threaded environments (like Tokio), Futures need to be `Send`. However, there is no stable syntax to express `Send` bounds on the Future returned by native `async fn` in traits.

```rust
// This compiles but Send bound is not guaranteed by the type system
trait MyTrait {
    async fn my_method(&self) -> Result<(), Error>;
}

// Potential issues when using with tokio::spawn
let handle = tokio::spawn(async move {
    my_trait_impl.my_method().await  // Error at tokio::spawn if the returned Future is not Send
});
```

**Solution with async_trait**: The `#[async_trait]` macro automatically adds `+ Send`.

**Workarounds for Native AFIT**:

```rust
// Method 1: Manual desugaring
// Note: This is no longer using native `async fn` in traits, but a manual equivalent.
trait MyTrait: Send + Sync {
    fn my_method(&self) -> impl std::future::Future<Output = Result<(), Error>> + Send;
}

// Method 2: Using the trait-variant crate
#[trait_variant::make(SendMyTrait: Send)]
trait MyTrait {
    async fn my_method(&self) -> Result<(), Error>;
}
```

#### 2. Not Object-Safe

Traits containing native `async fn` cannot be used as `dyn Trait`:

```rust
trait MyTrait {
    async fn my_method(&self);
}

// This is a compile error
fn use_trait(obj: &dyn MyTrait) { ... }
```

This is because native `async fn` in traits desugars to return-position `impl Future`, which makes the trait not object-safe.

#### 3. Future Improvements

**Return Type Notation (RTN)** has been proposed (RFC 3654), and once stabilized, it will allow expressing bounds on method return types:

```rust
// Illustrative example (syntax not finalized)
trait MyTrait {
    async fn my_method(&self) -> Result<(), Error>;
}

fn use_trait<T: MyTrait>()
where
    T::my_method(..): Send,  // Add Send bound to method return type
{
    // ...
}
```

> Note: The exact syntax is not finalized yet. RTN is still under development and may change before stabilization.

### Current Situation in moto-hses

- **Tokio usage**: Using multi-threaded runtime, `Send` bound is required
- **SharedHsesClient**: Shared across multiple tasks, methods must return `Send` Futures
- **Performance requirements**: Network I/O (UDP communication) is the bottleneck; heap allocation overhead is negligible

### Evaluation of Options

| Option | Pros | Cons |
|--------|------|------|
| **Continue using async_trait** | Simple, Send bound handled automatically | Heap allocation, dependency |
| **Native AFIT + manual desugaring** | No allocation | Verbose signatures, complex implementation |
| **trait-variant crate** | Near-native syntax | Less widely adopted |

## Decision

We will use `async_trait` for the `HsesClientOps` trait.

## Consequences

### Positive

1. **Negligible performance impact**: Network I/O is the main bottleneck; heap allocation (nanoseconds) is negligible compared to communication latency (milliseconds)

2. **Send bound handled automatically**: Guaranteed safe operation in Tokio's multi-threaded environment

3. **Stability**: `async_trait` is widely used and has proven track record

4. **Simple implementation**: Clean and readable trait definitions without manual desugaring

5. **dyn Trait support**: If needed in the future, `async_trait` supports dynamic dispatch

### Negative

1. **Heap allocation**: Every async method call allocates a `Box<dyn Future>`

2. **Additional dependency**: Requires the `async_trait` crate

### Future Considerations

- When Rust's Return Type Notation (RTN) is stabilized, migration to native AFIT should be reconsidered
- If `dyn Trait` support becomes necessary, `async_trait` remains the only viable option
- For public library APIs, careful consideration of backward compatibility is needed when migrating

## References

- [Announcing `async fn` and return-position `impl Trait` in traits | Rust Blog](https://blog.rust-lang.org/2023/12/21/async-fn-rpit-in-traits/)
- [RFC 3185: Static async fn in traits](https://rust-lang.github.io/rfcs/3185-static-async-fn-in-trait.html)
- [RFC 3654: Return Type Notation](https://rust-lang.github.io/rfcs/3654-return-type-notation.html)
- [Asynchronous Programming in Rust - Async in Traits](https://rust-lang.github.io/async-book/07_workarounds/05_async_in_traits.html)
