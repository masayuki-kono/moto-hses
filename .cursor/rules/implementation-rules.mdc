---
description: "Implementation rules for Moto-HSES Rust Client. USE WHEN: implementing features, running tests, or reviewing code."
globs: "**/*"
alwaysApply: true
---

# Moto-HSES Rust Client Library Development Rules

## Development Approach

This project follows the implementation guide (`docs/design/implementation-guide.md`) to implement features step by step, ensuring that unit tests pass at each stage of development.

## Basic Rules

### 1. Incremental Implementation Principle

- Implement from Phase 1 (Protocol Layer) following the implementation guide
- Run unit tests after each step completion and ensure all tests pass
- If tests fail, do not proceed to the next step until fixes are complete

### 2. Specification Reference Priority

When there are unclear points, refer to specifications in the following order:

1. `docs/design/implementation-guide.md` - Implementation Guide
2. `docs/design/client-api.md` - API Design Specification
3. `docs/design/architecture.md` - Architecture Design
4. `docs/specs/hses-protocol.md` - HSES Protocol Specification

### 3. Code Quality

- Follow Rust best practices
- Resolve `cargo clippy` warnings
- Use `cargo fmt` to standardize code formatting
- Implement appropriate error handling

## Implementation Phase Rules

### Phase 1: Protocol Layer (moto-hses-proto)

#### Step 1: Core Types and Traits

- Implement `Command` trait and `VariableType` trait
- Define basic enum types (`Division`, `Service`, `CoordinateSystem`, etc.)
- Implement `Variable<T>` struct
- Unit tests: Test type definitions and basic functionality

#### Step 2: Enhanced Command System

- Type-safe command definitions (`ReadVar<T>`, `WriteVar<T>`, etc.)
- Structures for multiple variable operations (`ReadVars<T>`, `WriteVars<T>`)
- Status and position information operation command definitions
- Unit tests: Test command serialization/deserialization

#### Step 3: Enhanced Error Handling

- Implement `ProtocolError` enum
- Error handling with detailed error information
- Implement `Status` struct and bit flag processing
- Unit tests: Test error cases and status parsing

#### Step 4: Efficient Variable Operations

- Automatic grouping of consecutive variables
- Efficient batch operations using multiple commands (0x33)
- Padding processing for 1-byte variable types
- Unit tests: Test batch operation optimization and padding processing

### Phase 2: Client Layer (moto-hses-client)

#### Step 1: Client Structure

- Implement `HsesClient` struct and `ClientConfig`
- Basic UDP socket communication functionality
- Request ID management and pending request tracking
- Unit tests: Test client creation and basic configuration

#### Step 2: Client Implementation

- Implement high-level API methods
- Generic command sending functionality
- Response waiting and deserialization
- Unit tests: Test API calls and response processing

### Phase 3: Mock Server (moto-hses-mock)

#### Step 1: Mock Server Structure

- Implement `MockHsesServer` struct
- Custom handler registration functionality
- Basic request processing functionality
- Unit tests: Test mock server basic functionality

## Testing Strategy

### Unit Test Execution

```bash
# Protocol layer tests
cd moto-hses-proto && cargo test

# Client layer tests
cd moto-hses-client && cargo test

# Mock server tests
cd moto-hses-mock && cargo test
```

### Test Quality Standards

- Test both normal and abnormal cases for each feature
- Test edge cases (boundary values, invalid data)
- Verify performance requirements (batch operation efficiency, etc.)
- Check for memory leaks and resource management

## Code Review Criteria

### Implementation Quality

- Does it conform to the implementation guide specifications?
- Is type safety ensured?
- Is error handling appropriate?
- Is performance considered?

### Test Quality

- Do all unit tests pass?
- Is test coverage sufficient?
- Are edge cases tested?

### Documentation Quality

- Are code comments appropriate?
- Is API documentation up to date?
- Is consistency maintained with the implementation guide?

## Debugging and Troubleshooting

### Common Issues

1. **Protocol Errors**: Verify consistency with HSES specification
2. **Type Errors**: Check `VariableType` trait implementation
3. **Serialization Errors**: Verify byte order and data structure
4. **Network Errors**: Check UDP communication settings and timeouts

### Debugging Tools

- Use `cargo test -- --nocapture` to check test output
- Use `println!` or `dbg!` macros to output debug information
- Use Wireshark to analyze network packets

## Performance Considerations

### Memory Management

- Use `bytes` crate for efficient buffer management
- Utilize zero-copy operations
- Reduce allocations through buffer reuse

### Concurrency

- Use atomic operations for request ID management
- Use thread-safe HashMap for pending request tracking
- Use connection pooling for high-performance operations

### Batch Operations

- Automatic grouping of consecutive variables
- Utilize multiple commands (0x33)
- Reduce network round trips

## Continuous Integration

### Automated Checks

- `cargo check` - Check for compilation errors
- `cargo clippy` - Check code quality
- `cargo test` - Run unit tests
- `cargo fmt --check` - Check code formatting

### Quality Gates

- All tests must pass
- Clippy warnings must be resolved
- Code formatting must be standardized
- Consistency with implementation guide must be maintained

## Emergency Response

### Inconsistency with Implementation Guide

1. Recheck the relevant section of the implementation guide
2. Refer to related specifications (client-api.md, architecture.md, hses-protocol.md)
3. Update implementation guide if necessary

### Test Failure Response

1. Analyze failed test cases in detail
2. Verify consistency between implementation and specification
3. Apply fixes incrementally
4. Re-run all tests after fixes

### Performance Issues

1. Identify bottlenecks using profiling tools
2. Verify batch operation optimization
3. Analyze memory usage and allocation count
4. Improve algorithms if necessary
