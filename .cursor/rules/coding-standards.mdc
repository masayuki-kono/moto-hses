---
description: "Coding standards and quality rules for Moto-HSES Rust Client. USE WHEN: writing code, reviewing code, or ensuring code quality."
globs: "**/*"
alwaysApply: true
---

# Moto-HSES Rust Client Library Coding Standards

## Code Quality Rules

### unwrap_or(MAX_VALUE) Fallback is NG

**CRITICAL**: Never use `unwrap_or(MAX_VALUE)` for type conversions.

```rust
// ❌ DANGEROUS - Silent failure with wrong value
let offset = u16::try_from(offset_value).unwrap_or(u16::MAX);

// ✅ SAFE - Explicit error handling
let offset = u16::try_from(offset_value)
    .map_err(|_| format!("I/O offset {offset_value} exceeds u16::MAX"))?;
```

**Reason**: Using `unwrap_or(MAX_VALUE)` can cause severe issues by silently mapping out-of-range values to maximum values, leading to incorrect calculations and potential system failures.

**Rule**: Always use proper error handling with `map_err` or explicit `match` statements for type conversions.

### Use Inline Format Arguments in format! Macro

**CRITICAL**: Always use inline format arguments in `format!` macro to avoid Clippy warnings.

```rust
// ❌ BAD - Causes clippy::uninlined_format_args warning
let message = format!("Error: {} occurred at line {}", error, line);

// ✅ GOOD - Use inline format arguments
let message = format!("Error: {error} occurred at line {line}");
```

**Reason**: Inline format arguments are more readable, performant, and avoid Clippy warnings.

**Rule**: Always use `{variable}` syntax instead of separate arguments in `format!` macro.

### Include Causative Parameters in Error Messages

**CRITICAL**: Always include the actual parameter values that caused the error in error messages.

```rust
// ❌ BAD - Generic error message without context
return Err(ProtocolError::InvalidMessage("Invalid count".to_string()));

// ✅ GOOD - Include the actual parameter value
return Err(ProtocolError::InvalidMessage(format!(
    "Invalid count: {count} (must be 1-474)"
)));

// ✅ GOOD - Include multiple parameters for complex validation
return Err(ProtocolError::InvalidMessage(format!(
    "Variable range exceeds maximum: {start_variable}-{end_variable} (max 99)"
)));
```

**Reason**: Including actual parameter values in error messages makes debugging significantly easier by providing immediate context about what went wrong.

**Rule**: Always include the actual parameter values that caused the error in error messages using inline format arguments.

### Use try_from() Instead of as Casting

**CRITICAL**: Use `try_from()` instead of `as` casting for type conversions.

```rust
// ❌ BAD - Silent truncation with as casting
let value = large_number as u8;

// ✅ GOOD - Explicit error handling with try_from
let value = u8::try_from(large_number)
    .map_err(|_| format!("Value {large_number} exceeds u8::MAX"))?;
```

**Reason**: `as` casting can silently truncate values, while `try_from()` provides explicit error handling for out-of-range conversions.

**Rule**: Use `try_from()` instead of `as` casting and implement proper error handling for type conversions.
